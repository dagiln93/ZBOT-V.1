–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –Ω–µ –º–æ–≥—É –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–≤–∞—Ç—å Replit-–ø—Ä–æ–µ–∫—Ç—ã –æ—Ç –º–æ–µ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞, –Ω–æ —è –º–æ–≥—É –¥–∞—Ç—å —Ç–µ–±–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≥–æ—Ç–æ–≤—ã–π —à–∞–±–ª–æ–Ω, –∫–æ—Ç–æ—Ä—ã–π —Ç—ã —Å–º–æ–∂–µ—à—å –≤—Ä—É—á–Ω—É—é –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∏–ª–∏ –≤—Å—Ç–∞–≤–∏—Ç—å –≤ Replit —á–µ—Ä–µ–∑ –∫–æ–¥–æ–≤–æ–µ –º–µ–Ω—é. –í–æ—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:

üìÅ 1. –§–∞–π–ª—ã –ø—Ä–æ–µ–∫—Ç–∞
main.py
python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
from flask import Flask, render_template, request
import zcore

app = Flask(__name__)

@app.route("/", methods=["GET", "POST"])
def index():
    results = None
    if request.method == "POST":
        results = zcore.run_analysis()
    return render_template("index.html", results=results)

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=81)
zcore.py
python
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from pybit.unified_trading import HTTP

BYBIT_API = HTTP()
HISTORY_DAYS = 30
INTERVAL = "240"
Z_LEN = 14
THRESHOLD = 2.0
SL_PCT = 0.5
TP_PCT = 1.0

def fetch_klines(symbol):
    limit = HISTORY_DAYS * (1440 // int(INTERVAL)) + Z_LEN + 20
    resp = BYBIT_API.get_kline(category="linear", symbol=symbol, interval=INTERVAL, limit=limit)
    df = pd.DataFrame(resp['result']['list'], columns=['start','open','high','low','close','volume','turnover'])
    df['time'] = pd.to_datetime(df['start'].astype(int), unit='ms')
    df.set_index('time', inplace=True)
    for col in ['open','high','low','close','volume']:
        df[col] = df[col].astype(float)
    return df

def compute_indicators(df):
    df['ma_z'] = df['close'].rolling(Z_LEN).mean()
    df['std_z'] = df['close'].rolling(Z_LEN).std()
    df['zscore'] = (df['close'] - df['ma_z']) / df['std_z']
    df['sma50'] = df['close'].rolling(50).mean()
    df['vol_sma20'] = df['volume'].rolling(20).mean()
    return df

def gen_signals(df):
    df = df.dropna(subset=['zscore','sma50','vol_sma20'])
    df['signal_type'] = np.where((df['zscore'].shift(1) < -THRESHOLD) & (df['zscore'] >= -THRESHOLD), 'long',
                                 np.where((df['zscore'].shift(1) > THRESHOLD) & (df['zscore'] <= THRESHOLD), 'short', None))
    sig = df[df['signal_type'].notnull()].copy()
    sig = sig[((sig['signal_type']=='long') & (sig['close']>sig['sma50'])) |
              ((sig['signal_type']=='short') & (sig['close']<sig['sma50']))]
    sig = sig[sig['volume']>sig['vol_sma20']]
    sig['type'] = sig['signal_type']
    sig['price'] = sig['close']
    sig['time'] = sig.index
    return sig[['type','price','time']]

def precision_by_symbol(symbol, signals, df):
    # –ø—Ä–æ—Å—Ç–∞—è –æ—Ü–µ–Ω–∫–∞ precision: —Å–∫–æ–ª—å–∫–æ —Å–∏–≥–Ω–∞–ª—ã —Å—Ä–∞–±–æ—Ç–∞–ª–∏ TP / total
    pnl = []
    for t,s in signals.iterrows():
        entry = s['price']
        fut = df.loc[t:]
        if s['type']=='long':
            tp = entry*(1+TP_PCT/100)
            pnl.append((fut['high']>=tp).any())
        else:
            tp = entry*(1-TP_PCT/100)
            pnl.append((fut['low']<=tp).any())
    return np.mean(pnl)

def run_analysis():
    syms = [i['symbol'] for i in BYBIT_API.get_instruments_info(category="linear")['result']['list']
            if i['status']=="Trading"]
    results = []
    for sym in syms:
        df = fetch_klines(sym)
        df = compute_indicators(df)
        sig = gen_signals(df)
        if sig.empty: continue
        precis = precision_by_symbol(sym, sig, df)
        last = sig.iloc[-1]
        age = datetime.utcnow() - last['time'].to_pydatetime()
        results.append({
            'symbol': sym,
            'direction': last['type'],
            'price': round(last['price'],6),
            'strength': abs(last['zscore']),
            'precision': round(precis,3),
            'still_valid': age < timedelta(hours=4)
        })
    # —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ, –ø–æ—Ç–æ–º –ø–æ precision, strength
    out = sorted(results, key=lambda x:(not x['still_valid'], -x['precision'], -x['strength']))
    return out[:10]
templates/index.html
html
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
<!DOCTYPE html>
<html>
<head>
  <title>Z-Score Bot</title>
</head>
<body>
  <h2>üìà Z‚ÄëScore Mean Reversion Signals (4H)</h2>
  <form method="post"><button type="submit">–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∞–ª–∏–∑</button></form>
  {% if results %}
  <table border="1" cellpadding="5">
    <tr><th>#</th><th>–°–∏–º–≤–æ–ª</th><th>–ù–∞–ø—Ä–∞–≤–ª.</th><th>–¶–µ–Ω–∞</th><th>–°–∏–ª–∞</th><th>–¢–æ—á–Ω–æ—Å—Ç—å</th><th>–í —Å–∏–ª–µ?</th></tr>
    {% for r in results %}
    <tr>
      <td>{{ loop.index }}</td>
      <td>{{ r.symbol }}</td>
      <td>{{ 'üü©' if r.direction=='long' else 'üü•' }}</td>
      <td>{{ r.price }}</td>
      <td>{{ r.strength|round(2) }}</td>
      <td>{{ (r.precision*100)|round(1) }}%</td>
      <td>{{ '‚úÖ' if r.still_valid else '‚ùå' }}</td>
    </tr>
    {% endfor %}
  </table>
  {% endif %}
</body>
</html>
üöÄ –ö–∞–∫ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ Replit
–ù–∞ Replit –Ω–∞–∂–º–∏ "Create App ‚Üí Python".

–ó–∞–º–µ–Ω–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π main.py –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã–π –∫–æ–¥.

–î–æ–±–∞–≤—å —Ñ–∞–π–ª—ã zcore.py –∏ templates/index.html –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –º–µ—Å—Ç–∞.

–£–∫–∞–∂–∏ –≤ poetry.sh –∏–ª–∏ Shell:

nginx
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
pip install flask pandas numpy pybit
–ù–∞–∂–º–∏ Run ‚Äî –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è.

–í –±—Ä–∞—É–∑–µ—Ä–µ —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –ø–µ—Ä–µ–π–¥–∏ –ø–æ —Å—Å—ã–ª–∫–µ –≤–∏–¥–∞ https://<—Ç–≤–æ–π-–ø—Ä–µ–∫—Ç-–∏–º—è>.<username>.repl.co

üì± –ñ–º–∏ –∫–Ω–æ–ø–∫—É "–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∞–ª–∏–∑", —É–≤–∏–¥–∏—à—å —Ç–æ–ø-10 –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤ —Å —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–æ–π.